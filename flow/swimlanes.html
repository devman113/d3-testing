<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Basic GoJS Sample</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.13.2/tingle.min.css">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.6-rc.0/css/select2.min.css" rel="stylesheet" />
  <link rel="stylesheet" type="text/css" href="../css/dragula.css">
  <link rel="stylesheet" type="text/css" href="../css/checkbox.css">
  <link rel="stylesheet" type="text/css" href="../css/custom.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gojs/1.8.31/go.js"></script>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.6-rc.0/js/select2.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.13.2/tingle.min.js"></script>
</head>
<body onload="init()">
  <div class="main-container">
    <div class="left-panel">
				<h4>Advanced filter</h4>
        <div class="wrapper panel panel-body">
					<div id="filtersList" class="cont-dragula">
					</div>
				</div>
    </div>
    <div class="view-container">
      <div class="connector-container">
        <div class="select-container">
          <span>From:</span>
          <select id="fromColumns" class="customSelect"></select>
        </div>
        <div class="select-container">
          <span>To:</span>
          <select id="toColumns"  class="customSelect"></select>
        </div>
        <div class="select-container">
          <input type="checkbox" id="checkBilateral">
          <label class="columnLabel" id="label#Bilateral" for="checkBilateral">Bilateral</label>
        </div>
        <button onclick="insertConnection()">Insert</button>
      </div>
      <br />
      <div id="myDiagramDiv" style="border: solid 1px black; width: 1200px; height: 800px"></div>
    </div>
  </div>
  <script src="swimlanes.js"></script>
  <script id="code">
    var dataSet = [], transformationData = [];
    var availableOptions = [];
    var availableColumn;
		var blockList = {};
    var NO_SUBSYSTEM = 'No Subsystem';
    var NO_SYSTEM = 'No System';
    var FIXED_WIDTH = 200;

    var sortedSubSystems = [];
    var sortedSystems = [];

    // Create the Diagram's Model:
    var dataSource = jQuery.getJSON('http://localhost:8000/data/mockDataAssociated.json');
    var dataTransformation = jQuery.getJSON('http://localhost:8000/data/DataTransformation.json');
      
    jQuery.when(dataSource, dataTransformation)
      .done(function(dataSourceResult, dataTransformationResult) {
        //data is the JSON string
        transformationData = dataTransformationResult[0]['dataTransformation']['data'];
        dataSet = dataSourceResult[0]['columns'];

        var filters = Object.keys(dataSet[0]);
        generateColumns(filters);

        dataSet = assignUniqueId(dataSet);
        configureColumnSelects(dataSet);

        getNodeLink();
        generateSortedSystemSubSystem(dataSet);
        generateViewByNodeLink();
        
      });
    function generateSortedSystemSubSystem(dataSet) {
      var subSystems = dataSet.map(record => record['Subsystem']);
      var systems = dataSet.map(record => record['System']);

      var countsOfSystem = generateOrderedList(systems)['listMap'];
      var countsOfSubSystem = generateOrderedList(subSystems)['listMap'];

      sortedSubSystems = generateOrderedList(subSystems)['keysSorted'];
      sortedSystems = generateOrderedList(systems)['keysSorted'];
      createView(sortedSystems, sortedSubSystems);
    }
    function generateColumns(filters) {
      filters.forEach(filter => {
        var content = `<div class="singleColumnContainer">`;
        content += `<input type="checkbox" checked="true" class="checkList" id="filtersListcheck#${filter}">`;
        content += `<label class="columnLabel" id="filtersListlabel#${filter}" for="filtersListcheck#${filter}">${filter}</label>`
        content += `<span class="moreFilters" onclick="generateFilterOptions('`+filter+`')">&gt;</span></div>`;
        $('#filtersList').append(content);
      });
    }
    function generateFilterOptions(columnName) {
      availableOptions = [];
      availableColumn = columnName;
      for (var i = 0; i < dataSet.length; i++) {
        var eachColumn = dataSet[i][columnName];
        if (availableOptions.indexOf(eachColumn) < 0) {
          availableOptions.push(eachColumn);
        }
      }
      generateFilterModalContent(availableOptions, columnName);
    }

    function filterOptionChange() {
      var category = availableColumn;
      blockList[category] = [];
      var properties  = document.getElementsByClassName("eachProperty");
      var propertyArray = Array.prototype.slice.call(properties);
      
      propertyArray.forEach((property) => {
        var pos = property.id.split('#')[2];
        var itemToBlock = availableOptions[pos];

        if (itemToBlock.length > 3)
        if (itemToBlock.substr(0, 3) === 'No ') itemToBlock = '';
        
        if (document.getElementById(property.id).checked === false) blockList[category].push(itemToBlock);
      });

      // dataSet.forEach(singleData => {
      //   var node = myDiagram.findNodeForKey(singleData.id);
      //   if (node) {
      //     if (checkBlocking(singleData)) 
      //       myDiagram.remove(node);
            // nodeDataArray = nodeDataArray.filter(function(singleNode){
            //   return singleNode.key !== node.key;
            // });
            // console.log(nodeDataArray)
      //   } else {
      //     if (!checkBlocking(singleData))
      //       addNewNode(singleData.id, `system#${singleData['System']}`, singleData['Program Name']);
      //   }
      // });

      // getNodeLink();
      // generateViewByNodeLink();
    }
    function checkBlocking(dataElement) {
      var isBlocked = false;
      Object.keys(dataElement).some(property => {
        if (blockList[property]) {
          if (blockList[property].indexOf(dataElement[property]) > -1) {
            isBlocked = true;
            return;
          }
        }
      });
      return isBlocked;
    }
    function assignUniqueId(dataSet) {
      return dataSet.map((eachRecord, i) =>  { eachRecord['id'] = `record#${i}`; return eachRecord; });
    }
    function configureColumnSelects(dataSet) {
      dataSet.forEach(eachRecord => {
        $('.customSelect').append($('<option>', {
            value: eachRecord['id'],
            text: eachRecord['Program Name']
        }));
      });
    }
    $(document).ready(function() {
      $('.customSelect').select2();
    });   

    // --- Node & Link manipulation ---
    // var colorsArray = ["#FF5252","#69B40F","#EC1D25","#C8125C","#008FC8","#10218B","#134B24","#737373"];
    // var maxFrom = 1000, maxTo = 2000;
    // var heightUnit = 40;
    // var fromPosX = 100;
    // var toPosX = 600;
    // var dbPosX = 1000;
    // var maxColumn = 15;

    // var countingCollection = {};

    // var nodeDataArray = [];
    // var linkDataArray = [];

    // function createView(sortedSystems, sortedSubSystems) {
    //   saveCounting(sortedSystems, sortedSubSystems)
    //   sortedSystems.forEach(record => {
    //       nodeDataArray.push({
    //         key: `system#${record}`, 
    //         text: record === "" ? "No System" : record, 
    //         color: colorsArray[0], 
    //         isGroup: true,
    //         loc: `${posSwimlane['x'][record]}, 0`
    //       });
    //   });
    //   dataSet.forEach(singleData => {
    //     if (!checkBlocking(singleData))
    //     addNewNode(singleData.id, `system#${singleData['System']}`, singleData['Program Name']);
    //   });  
    // }
    // function saveCounting(sortedSystems, sortedSubSystems) {
    //   sortedSystems.forEach(system => {
    //     countingCollection[system === '' ? NO_SYSTEM : system] = {};
    //     sortedSubSystems.forEach(subSystem => {
    //       countingCollection[system === '' ? NO_SYSTEM : system][subSystem === '' ? NO_SUBSYSTEM : subSystem] = 0
    //     });
    //   });
    // }
    // function addNewNode(key, group, text) {
    //   var obj = dataSet.filter(obj => obj.id === key);
    //   var isExisting = nodeDataArray.find( node => node.key === key );
    //   var system = obj[0]["System"];
    //     var subSystem = obj[0]["Subsystem"];
    //   var subSystemOrder = sortedSubSystems.indexOf(subSystem);

    //   if (!isExisting) {
    //     system = system === '' ? NO_SYSTEM : system;
    //     subSystem = subSystem === '' ? NO_SUBSYSTEM : subSystem;
    //     var currentPos = countingCollection[system][subSystem];

    //     var nodeFrom = {
    //       key: key,
    //       text: text,
    //       color: colorsArray[subSystemOrder % colorsArray.length],
    //       group: group,
    //       loc: `${(posSwimlane['x'][system]+Math.ceil(currentPos/maxColumn)+1)*(FIXED_WIDTH+50)}, ${(posSwimlane['y'][subSystem]+currentPos%maxColumn)*heightUnit}`
    //     };

    //     countingCollection[system][subSystem] += 1;

    //     nodeDataArray.push(nodeFrom);
    //     myDiagram.model.addNodeData(nodeFrom);
    //   }
    // }
    // function insertConnection() {
    //   var fromIndex = $('#fromColumns').val();
    //   var toIndex = $('#toColumns').val();
    //   addNewLink(fromIndex, toIndex);
    //   if (document.getElementById("checkBilateral").checked === true)
    //   addNewLink(toIndex, fromIndex);
    // }
    // function addNewLink(fromIndex, toIndex) {
    //   myDiagram.model.addLinkData({ "from": fromIndex, "to":  toIndex });
    // }
    // function generateViewByNodeLink() {
    //   myDiagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
    // }
    // function getNodeLink() {
    //   transformationData.forEach((eachTransform) => {      
    //     linkDataArray.push({
    //       from: eachTransform.from,
    //       to: eachTransform.to
    //     });
    //   });
    //   return {
    //     nodeDataArray: nodeDataArray,
    //     linkDataArray: linkDataArray
    //   }
    // }
    // ----- Modal Configuration -----
    var modal = new tingle.modal({
      footer: true,
      stickyFooter: false,
      closeMethods: ['overlay', 'button', 'escape'],
      closeLabel: "Close",
      cssClass: ['custom-class-1', 'custom-class-2'],
      onOpen: function() {
        console.log('modal open');
      },
      onClose: function() {
        console.log('modal closed');
      },
      beforeClose: function() {
        // here's goes some logic
        // e.g. save content before closing the modal
        return true; // close the modal
        return false; // nothing happens
      }
    });
    modal.addFooterBtn('Close', 'tingle-btn tingle-btn--primary', function() {
      // here goes some logic
      modal.close();
    });
    function generateFilterModalContent(availableOptions, columnName) {
      var modalContent = '<div class="filterOptionContainer">';
      availableOptions.forEach((option, i) => {
        var col = columnName.replace(/\s/g, '');
        var elementId = `${col}#${i}`;
        var isChecked = "checked";
        if (blockList[columnName]) {
          if (blockList[columnName].indexOf(option) > -1) isChecked = "unchecked";
        }
        if (option === "") option = `No ${columnName}`;
        modalContent += '<div><input type="checkbox" class="eachProperty" id="checkboxFilter#'+elementId+'" onChange="filterOptionChange()" '+isChecked+' />';
        modalContent += '<label class="columnLabel" id="labelFilter#'+elementId+'" for="checkboxFilter#'+elementId+'">'+option+'</label></div>';
      });
      modalContent += '</div>';
      modal.setContent(modalContent);
      modal.open(); 
      return modalContent;
    }
    // ---- helpers -----
    function generateOrderedList(list) {
      var listMap = list.reduce(function (p, c) {
            p[c] = (p[c] || 0) + 1;
            return p;
      }, {});
      var keysSorted = Object.keys(listMap).sort(function(a,b){return listMap[b]-listMap[a]});
      return { listMap, keysSorted} ;
    }
  </script>
</body>
</html>